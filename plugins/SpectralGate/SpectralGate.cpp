#include "SpectralGate.h"#include "embed.h"#include "plugin_export.h"#include "Engine.h"#include "AudioEngine.h"#include "Song.h"#include <vector>#include <complex>#include <cmath>#include <string>#include <cctype>#include <algorithm>#include <random>namespace lmms{using Complex = std::complex<float>;static const float PI = 3.14159265358979323846f;// IMPORTANT: We use a member variable for size now, but for this implementation// we stick to a fixed size to keep the buffer logic simple for now.static const int FIXED_FFT_SIZE = 2048;/*************************************************************** ** Recursive FFT ***************************************************************/static void fft_recursive(std::vector<Complex>& x, bool inverse){    size_t N = x.size();    if (N <= 1) return;    std::vector<Complex> even(N/2), odd(N/2);    for (size_t i = 0; i < N/2; ++i)    {        even[i] = x[2*i];        odd[i]  = x[2*i + 1];    }    fft_recursive(even, inverse);    fft_recursive(odd,  inverse);    float ang = (inverse ? -2.f : 2.f) * PI / N;    Complex wn(std::cos(ang), std::sin(ang));    Complex w(1.f, 0.f);    for (size_t i = 0; i < N/2; ++i)    {        x[i]        = even[i] + w * odd[i];        x[i+N/2]    = even[i] - w * odd[i];        if (inverse)        {            x[i]     *= 0.5f;            x[i+N/2] *= 0.5f;        }        w *= wn;    }}/*************************************************************** ** SimpleParser ***************************************************************/class SimpleParser{public:    Complex eval(const std::string& expression, float freq);private:    std::string str;    size_t pos;    float currentFreq;    char peek();    char get();    Complex parseExpression();    Complex parseTerm();    Complex parsePower();    Complex parsePrimary();};char SimpleParser::peek(){    while (pos < str.length() && std::isspace((unsigned char)str[pos]))        pos++;    return (pos < str.length()) ? str[pos] : 0;}char SimpleParser::get(){    char c = peek();    if (pos < str.length()) pos++;    return c;}Complex SimpleParser::parsePrimary(){    char c = peek();    if (c == '(')    {        get();        Complex v = parseExpression();        if (peek() == ')') get();        return v;    }    if (std::isdigit((unsigned char)c) || c == '.')    {        size_t start = pos;        while (pos < str.length() &&               (std::isdigit((unsigned char)str[pos]) || str[pos] == '.'))            pos++;        float v = std::stof(str.substr(start, pos - start));        if (peek() == 'j') { get(); return Complex(0.f, v); }        return Complex(v, 0.f);    }    if (std::isalpha((unsigned char)c))    {        std::string tok;        while (pos < str.length() && std::isalpha((unsigned char)str[pos]))            tok += str[pos++];        if (tok == "freq") return Complex(currentFreq, 0.f);        if (tok == "w")    return Complex(2.f * PI * currentFreq, 0.f);        if (tok == "s")    return Complex(0.f, 2.f * PI * currentFreq);        if (tok == "j")    return Complex(0.f, 1.f);        if (tok == "pi")   return Complex(PI, 0.f);        if (peek() == '(')        {            get();            Complex arg = parseExpression();            if (peek() == ')') get();            if (tok == "sqrt") return std::sqrt(arg);            if (tok == "exp")  return std::exp(arg);            if (tok == "sin")  return std::sin(arg);            if (tok == "cos")  return std::cos(arg);            if (tok == "tan")  return std::tan(arg);            if (tok == "abs")  return Complex(std::abs(arg), 0.f);            if (tok == "log")  return std::log(arg);        }        return Complex(1.f, 0.f);    }    return Complex(0.f, 0.f);}Complex SimpleParser::parsePower(){    Complex lhs = parsePrimary();    while (peek() == '^')    {        get();        Complex rhs = parsePrimary();        lhs = std::pow(lhs, rhs);    }    return lhs;}Complex SimpleParser::parseTerm(){    Complex lhs = parsePower();    while (1)    {        char op = peek();        if (op == '*') { get(); lhs *= parsePower(); }        else if (op == '/') {            get();            Complex rhs = parsePower();            if (std::abs(rhs) < 1e-9f) rhs = Complex(1e-9f, 0.f);            lhs /= rhs;        }        else break;    }    return lhs;}Complex SimpleParser::parseExpression(){    Complex lhs = parseTerm();    while (1)    {        char op = peek();        if (op == '+') { get(); lhs += parseTerm(); }        else if (op == '-') { get(); lhs -= parseTerm(); }        else break;    }    return lhs;}Complex SimpleParser::eval(const std::string& expr, float freq){    str = expr;    pos = 0;    currentFreq = freq;    if (expr.empty()) return Complex(1.f, 0.f);    return parseExpression();}/*************************************************************** ** evalPreset ***************************************************************/static Complex evalPreset(SimpleParser& parser, int preset,                          const std::string& formula, float freq){    if (freq < 0.1f) freq = 0.1f;    if (preset == 1) return parser.eval(formula, freq);    Complex H(1.f, 0.f);    switch (preset)    {        case 2: H = 1.f / std::sqrt(1.f + std::pow(freq/800.f, 2)); break;        case 3: H = (freq < 500.f ? 0.f : 1.f); break;        case 4: H = 1.f + 1.f/(1.f + std::pow(freq/500.f,2)); break;        case 5: H = 1.f + 1.f/(1.f + std::pow(2000.f/(freq+1.f),2)); break;        case 6: H = (freq > 300.f && freq < 3000.f) ? 1.f : 0.f; break;        case 7: H = 1.f - std::exp(-std::pow(freq - 600.f, 2)/(2*40*40)); break;        case 8: H = 1.f + 8.f * std::exp(-std::pow(20.f*(freq-900.f)/900.f, 2)); break;        case 9: H = 1.f + std::exp(Complex(0, -1) * 2.f * PI * freq * 0.002f); break;        case 10: H = 1.f - std::exp(Complex(0, -1) * 2.f * PI * freq * 0.003f); break;        case 11: { float f=1200.f; H=(1.f-Complex(0,1)*(freq/f))/(1.f+Complex(0,1)*(freq/f)); } break;        case 12: H = (std::fmod(freq, 500.f) < 250.f) ? 1.f : -1.f; break;        case 13: H = std::exp(-0.0004f * freq); break;        case 14: H = (freq > 500.f) ? std::exp(-0.0008f*(freq-500.f)) * std::sin(freq*0.005f) : 0.f; break;        case 15: H = std::exp(-std::pow(freq-800.f, 2)/(2*6400.f)) +                     std::exp(-std::pow(freq-1500.f,2)/(2*22500.f)) +                     std::exp(-std::pow(freq-2500.f,2)/(2*40000.f)); break;        case 16: H = 1.f + 0.8f * std::sin(PI * freq / 200.f); break;        case 17: H = std::exp(Complex(0,1) * 0.0005f * freq); break;        default: H = Complex(1.f,0.f); break;    }    return H;}/*************************************************************** ** Plugin descriptor ***************************************************************/extern "C" {Plugin::Descriptor PLUGIN_EXPORT SpectralGate_plugin_descriptor ={    LMMS_STRINGIFY(PLUGIN_NAME),    "SpectralGate",    QT_TRANSLATE_NOOP("PluginBrowser", "Step-based spectral morph gate"),    "Your Name",    0x0100,    Plugin::Type::Effect,    new PixmapLoader("lmms-plugin-logo"),    nullptr,    nullptr};}/*************************************************************** ** Constructor ***************************************************************/SpectralGateEffect::SpectralGateEffect(Model* parent, const Descriptor::SubPluginFeatures::Key* key) :    Effect(&SpectralGate_plugin_descriptor, parent, key),    m_controls(this),    m_phase(0.0),    m_currentGain(0.f){    // Initialize Random Phase Map for Width    m_randomPhases.resize(FIXED_FFT_SIZE / 2 + 1);    std::mt19937 gen(1234); // Constant seed for consistency    std::uniform_real_distribution<float> dis(-PI, PI);    for (auto& p : m_randomPhases)        p = dis(gen);            // Init spectral feedback buffers    m_feedbackL.assign(FIXED_FFT_SIZE / 2 + 1, Complex(0,0));    m_feedbackR.assign(FIXED_FFT_SIZE / 2 + 1, Complex(0,0));}/*************************************************************** ** MAIN DSP ***************************************************************/Effect::ProcessStatusSpectralGateEffect::processImpl(SampleFrame* buf, const fpp_t frames){    // 1. TEMPO GATE    float bpm  = Engine::getSong()->getTempo();    float rate = Engine::audioEngine()->baseSampleRate();    float speed  = m_controls.m_speedModel.value();    float smooth = m_controls.m_smoothModel.value();    float swing  = m_controls.m_swingModel.value();    bpm = std::max(1.f, bpm); speed = std::max(0.01f, speed);    double sampBar  = (240.0 * rate) / bpm;    double sampStep = (sampBar / 16.0) / speed;    double swingOff = sampStep * swing * 0.75;    double threshold= sampStep + swingOff;    float inertia = smooth * 0.995f;    // LED index    double pairLen = sampStep * 2.0;    int blockIdx = ((int)(m_phase / pairLen)*2 + (fmod(m_phase, pairLen) < threshold ? 0 : 1)) % 16;    m_controls.setRunIndex(blockIdx);    // Gate Envelope    for (fpp_t i = 0; i < frames; ++i)    {        double pos = fmod(m_phase, pairLen);        int pairIndex = (int)(m_phase / pairLen);        int stepIndex = (pos < threshold ? 0 : 1);        stepIndex = (pairIndex * 2 + stepIndex) % 16;        bool isOpen = m_controls.getCurrentStep(stepIndex);        float target = (isOpen ? 1.f : 0.f);        if (smooth < 0.001f) m_currentGain = target;        else m_currentGain = m_currentGain * inertia + target * (1.f - inertia);        m_phase += 1.0;        if (m_phase >= sampBar) m_phase -= sampBar;    }    float spectralMix = m_currentGain;    // 2. STFT SETUP    if (m_window.size() != FIXED_FFT_SIZE)    {        m_window.resize(FIXED_FFT_SIZE);        m_historyL.assign(FIXED_FFT_SIZE, 0.f);        m_historyR.assign(FIXED_FFT_SIZE, 0.f);        m_overlapAddL.assign(FIXED_FFT_SIZE, 0.f);        m_overlapAddR.assign(FIXED_FFT_SIZE, 0.f);        for (int i = 0; i < FIXED_FFT_SIZE; ++i)            m_window[i] = 0.5f * (1.f - std::cos(2.f * PI * i / (FIXED_FFT_SIZE - 1)));                    m_randomPhases.resize(FIXED_FFT_SIZE / 2 + 1);        m_feedbackL.assign(FIXED_FFT_SIZE / 2 + 1, Complex(0,0));        m_feedbackR.assign(FIXED_FFT_SIZE / 2 + 1, Complex(0,0));    }    int hop = frames;    if (hop > FIXED_FFT_SIZE) hop = FIXED_FFT_SIZE;    std::copy(m_historyL.begin() + hop, m_historyL.end(), m_historyL.begin());    std::copy(m_historyR.begin() + hop, m_historyR.end(), m_historyR.begin());    for (int i = 0; i < hop; ++i)    {        m_historyL[FIXED_FFT_SIZE-hop+i] = buf[i][0];        m_historyR[FIXED_FFT_SIZE-hop+i] = buf[i][1];    }    std::vector<Complex> fL(FIXED_FFT_SIZE), fR(FIXED_FFT_SIZE);    for (int i = 0; i < FIXED_FFT_SIZE; ++i)    {        fL[i] = Complex(m_historyL[i] * m_window[i], 0.f);        fR[i] = Complex(m_historyR[i] * m_window[i], 0.f);    }    fft_recursive(fL, false);    fft_recursive(fR, false);    // 3. EQ + DECAY + WIDTH    int openPreset   = (int)m_controls.m_openPresetModel.value();    int closedPreset = (int)m_controls.m_closedPresetModel.value();    std::string openFormula   = m_controls.getOpenFormula().toStdString();    std::string closedFormula = m_controls.getClosedFormula().toStdString();    float oL = m_controls.m_openLowModel.value();    float oM = m_controls.m_openMidModel.value();    float oH = m_controls.m_openHighModel.value();    float cL = m_controls.m_closedLowModel.value();    float cM = m_controls.m_closedMidModel.value();    float cH = m_controls.m_closedHighModel.value();        float decay = m_controls.m_decayModel.value();    float width = m_controls.m_widthModel.value();        // Safety clamp decay    decay = std::clamp(decay, 0.f, 0.95f);     float fs = 44100.f;    float binWidth = fs / FIXED_FFT_SIZE;    float freqLow  = 250.0f;    float freqHigh = 4000.0f;    static SimpleParser parser;    // --- THIS IS THE LOOP THAT WAS MISSING ---    for (int i = 0; i <= FIXED_FFT_SIZE/2; ++i)    {        float freq = i * binWidth;                // A. EQ Curve Generation        float gainOpen = oM;        if (freq < freqLow)       gainOpen = oL;        else if (freq > freqHigh) gainOpen = oH;        float gainClosed = cM;        if (freq < freqLow)       gainClosed = cL;        else if (freq > freqHigh) gainClosed = cH;        Complex Ho = evalPreset(parser, openPreset,   openFormula,   freq);        Complex Hc = evalPreset(parser, closedPreset, closedFormula, freq);        Ho *= gainOpen;        Hc *= gainClosed;        float w = std::clamp(spectralMix, 0.f, 1.f);        Complex H = Ho * w + Hc * (1.f - w);                if (i == 0 || i == FIXED_FFT_SIZE/2) H = Complex(H.real(), 0.f);        // B. Apply EQ to signal        fL[i] *= H;        fR[i] *= H;                // C. Spectral Feedback (Decay/Blur)        fL[i] += m_feedbackL[i] * decay;        fR[i] += m_feedbackR[i] * decay;                // Store for next frame        m_feedbackL[i] = fL[i];        m_feedbackR[i] = fR[i];                // D. Stereo Width (Random Phase on Right Channel)        if (width > 0.01f)        {            float phi = m_randomPhases[i] * width;            fR[i] *= std::polar(1.f, phi);        }        // Conjugate symmetry (restore negative frequencies)        if (i > 0 && i < FIXED_FFT_SIZE/2)        {            fL[FIXED_FFT_SIZE-i] = std::conj(fL[i]);            fR[FIXED_FFT_SIZE-i] = std::conj(fR[i]);        }    }    fft_recursive(fL, true);    fft_recursive(fR, true);    float scale = 2.f * hop / FIXED_FFT_SIZE;    for (int i = 0; i < FIXED_FFT_SIZE; ++i)    {        m_overlapAddL[i] += fL[i].real() * scale;        m_overlapAddR[i] += fR[i].real() * scale;    }    for (int i = 0; i < hop; ++i)    {        buf[i][0] = m_overlapAddL[i];        buf[i][1] = m_overlapAddR[i];    }    std::copy(m_overlapAddL.begin() + hop, m_overlapAddL.end(), m_overlapAddL.begin());    std::copy(m_overlapAddR.begin() + hop, m_overlapAddR.end(), m_overlapAddR.begin());    std::fill(m_overlapAddL.end() - hop, m_overlapAddL.end(), 0.f);    std::fill(m_overlapAddR.end() - hop, m_overlapAddR.end(), 0.f);    return Effect::ProcessStatus::Continue;}extern "C" {PLUGIN_EXPORT Plugin* lmms_plugin_main(Model* parent, void* data){    return new SpectralGateEffect(parent, static_cast<const Plugin::Descriptor::SubPluginFeatures::Key*>(data));}}} // namespace lmms