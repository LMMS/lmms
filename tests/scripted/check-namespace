#!/usr/bin/python3

# This script checks the code for namespace related issues
# Note: This script is not perfect. It can not parse all LMMS files,
#       and does not contain a complete C++ parser. If you encounter
#       difficulties with this tests, it could be a fault of your
#       changes, but it could also be a fault of this script.

import argparse
import re
import subprocess
import sys
import tempfile
import xml.etree.ElementTree as ElementTree
from pathlib import Path
from typing import NamedTuple, Union




# types

class BlockType:
    pass


IF_MACRO = BlockType()
HEADER_GUARD = BlockType()
CODE_BLOCK = BlockType()
EXTERN = BlockType()


class Expectation(NamedTuple):
    type: BlockType
    statement: str  # expected end statement
    name: str  # expected name in comment


# global variables

errors = 0


# functions

def caption(my_str):
    print(f'\n# {my_str}\n', file=sys.stderr)


def error(message: str, file: Union[str, Path], line: int = None):
    global errors
    errors += 1
    if line is not None:
        file = f'{file}:{line}'
    print(f'Error: {file}: {message}', file=sys.stderr)


def line(match: re.Match):
    """Return line number of match"""
    return match.string[:match.start()].count('\n') + 1  # first line is 1


known_no_namespace_lmms = {
    # main.cpp
    'src/core/main.cpp',
    # nothing to set under a namespace
    'include/debug.h',
    'include/versioninfo.h',
    'plugins/CarlaBase/CarlaConfig/config.h',
    'plugins/CarlaBase/DummyCarla.cpp',
    # unclear why it has no namespace
    'plugins/ZynAddSubFx/RemoteZynAddSubFx.cpp',
}

exclude_files = re.compile(
    # not ours:
    'include/(aeffectx|fenv|ladspa).h|'
    'plugins/LadspaEffect/(calf|caps|cmt|swh|tap)/|'
    'plugins/MidiExport/MidiFile.hpp|'
    'plugins/ReverbSC/[a-z]|'
    'plugins/Sf2Player/fluidsynthshims.h|'
    '/portsmf/|'
    # only forward to headers that are not ours:
    'plugins/ZynAddSubFx/ThreadShims.h'
)

statement_pattern = re.compile(
    # Capture comments first to prevent them from matching any other regex
    #  Include next line if line ends with backslash
    r'/[*](.|\n)*?[*]/|//(.*\\\n)*.*|'

    # Macro with <30 lines and no other #if inside needs no end comment
    #  Match here to prevent from matching next regex
    #  With a (?!negative lookahead) we can allow all # except the ones followed by "if"
    r'^ *# *(?P<short_macro>ifn?def)(?=(([^#\n]|#(?!if|endif))*\n){,30} *# *endif)|'
    # Macro followed by name or comment
    #  With (?P<name>...) you can do a backreference to \name later
    r'^ *# *(?P<named_macro>ifn?def|endif)(( *// *| +)(?P<macro_name>\w+))?|'
    # Other macros where we don't want the argument
    r'^ *# *(?P<macro>include|if|el(se|if))|'

    # Namespace that contains no other braces needs no end comment
    #  With a (?=lookahead) we can let the "namespace" part be eaten by the parser
    #  but save the braces and their content for later so they can be matched again
    r'^ *namespace *[\w:]*\s*(?={[^{}]*})|'
    # Start of named namespace, extern "C" or just a opening brace
    r'(^ *(namespace +(?P<namespace>[\w:]+)|(?P<extern>extern *"C"))\s*)?(?P<opening_brace>{)|'
    # End of namespace including comment, or just a closing brace
    r'(?P<closing_brace>})( *// *namespace +(?P<namespace_end>[\w:]+))?|'

    # Class declaration
    r'(^ *class +([A-Z_]+_EXPORT +)*(?P<class>[\w]+))'

    # In all the regexes above match both tab and space when a space is used
    r''.replace(' ', r'[\t ]'),
    # Make ^ match on every line, not just beginning of file
    re.MULTILINE)

# Comments and whitespace followed by header guard
header_guard_pattern = re.compile(r'^(/[*](.|\n)*?[*]/|//.*|\s)*#\s*(ifndef|pragma\s+once)')

# Namespace lmms
namespace_pattern = re.compile(r'^\s*namespace\s+lmms', re.MULTILINE)

# Match <context> blocks in a .ts file
# The|or|statment will match in order of appearance, so if the <context> matches, it will eat the whole block.
# If not, it will match anything but "<" and at last matching a single "<".
# This will make sure it stops at every bracket and checks if it's a <context>.
# The {CLASSES} are for pythons format() to be able to insert names of the classes we want to delete.
ts_pattern_template = r'<context[^>]*>.*?<name[^>]*>({CLASSES})</name *>.*?</context *>\n|[^<]*|<'

#
# command line arguments
#

parser = argparse.ArgumentParser()
parser.add_argument('--delete-old-translations', action='store_true')
args = parser.parse_args()

# Make a list of all source files
if not Path('.gitmodules').is_file():
    print('You need to call this script from the LMMS top directory', file=sys.stderr)
    exit(1)

result = subprocess.run(['git', 'ls-files', '*.[ch]', '*.[ch]pp', ':!tests/*'],
                        capture_output=True, text=True, check=True)
files = [Path(f) for f in result.stdout.splitlines() if not exclude_files.search(f)]

#
# the real code
#

caption('namespace checks')

known_classes = set()

for cur_file in files:
    if cur_file.is_file():
        cur_text = cur_file.read_text(errors='replace')

        if cur_file.as_posix() not in known_no_namespace_lmms:
            namespace_pattern.search(cur_text) or error('File has no namespace lmms', cur_file)

        is_header = str(cur_file).endswith('.h')
        header_guard = is_header
        expectations = []  # type: list[Expectation]

        if header_guard:
            if not header_guard_pattern.match(cur_text):
                error('First statement should be header guard', cur_file)
                header_guard = False

        for m in statement_pattern.finditer(cur_text):
            # Keep a list of all class names
            if is_header and m.group('class'):
                cls = [e.name for e in expectations if e.type is CODE_BLOCK and e.name]
                cls.append(m.group('class'))
                known_classes.add('::'.join(cls))
                continue

            # Find the matched regex group
            statement = m.group('opening_brace') or m.group('closing_brace')
            if not statement:
                statement = '#' + (m.group('macro') or m.group('named_macro') or m.group('short_macro') or '')
            if not statement or statement == '#':
                continue

            # Start statements
            if statement == '{':
                etype = EXTERN if m.group('extern') else CODE_BLOCK
                expectations.append(Expectation(etype, '}', m.group('namespace')))
            elif statement.startswith('#if'):
                etype = HEADER_GUARD if header_guard else IF_MACRO
                expectations.append(Expectation(etype, '#endif', m.group('macro_name')))
                header_guard = False

            # End statements
            elif statement == '#endif' or statement.startswith('#el') or statement == '}':
                if not expectations:
                    error(f'Unexpected {statement}', cur_file, line(m))
                    break
                if statement.startswith('#el') and expectations[-1].statement == '#endif':
                    # After an #else or #elif the comment is no longer mandatory, since it's hard to define
                    expectations[-1] = Expectation(IF_MACRO, '#endif', '')
                    # Don't pop the expectations, we are still waiting for the #endif
                    continue
                exp = expectations.pop()
                name = m.group('macro_name') or m.group('namespace_end') or ''
                if statement != exp.statement:
                    error(f'Expected {exp.statement} before {statement}', cur_file, line(m))
                    break
                # Require no end comment for header guard
                elif exp.type is HEADER_GUARD and not name:
                    continue
                elif exp.name and name != exp.name:
                    comment = 'namespace ' if exp.type is CODE_BLOCK else ''
                    error(f'Missing comment // {comment}{exp.name}', cur_file, line(m))

            # Extra checks
            elif statement == '#include':
                if any(True for e in expectations if e.type is CODE_BLOCK):
                    error('#include inside a code block', cur_file, line(m))

        else:
            # Leftover expected statements
            for exp in reversed(expectations):
                error(f'Expected {exp.statement} before end of file', cur_file)


caption('generating localization files')

# Let lupdate extract the context/class names of all translatable strings currently in the code
temp = tempfile.NamedTemporaryFile(mode='wt', dir='.', suffix='.ts', delete=False)
temp.write('<TS></TS>\n')
temp.close()
try:
    subprocess.run(['bash', 'buildtools/update_locales', temp.name], check=True, stdout=subprocess.DEVNULL)
    text = Path(temp.name).read_text()
finally:
    Path(temp.name).unlink()


caption('localization checks')

# Find invalid class names in the just generated .ts file
root = ElementTree.fromstring(text)
for context in root.iterfind('context'):
    # <name> should be a class in the lmms namespace
    name = context.find('name')
    if name is None or name.text is None:
        continue
    elif not name.text.startswith('lmms::'):
        msg = f'Translation context "{name.text}" is outside the lmms namespace'
    elif name.text not in known_classes:
        msg = f'Translation context "{name.text}" is not a known class'
    else:
        continue
    # Repeat error message for every occurrence in the code
    for location in context.iter('location'):
        error(msg, location.attrib.get('filename'), int(location.attrib.get('line')))

# Find invalid class names or missing paths in all our translation files
outdated_files = set()
outdated_classes = set()
for file in Path('data/locale').glob('*.ts'):
    tree = ElementTree.parse(str(file))
    root = tree.getroot()
    for location in root.iterfind('./context/message/location'):
        filename = location.attrib.get('filename')
        # The files sometimes are relative to data/local and sometimes to the git tree's root...
        if filename and not Path(filename).is_file() and not Path(f'data/locale/{filename}').is_file():
            error(f'Source file does not exist: {filename}', file)
    for name in root.iterfind('./context/name'):
        if name.text and name.text not in known_classes:
            outdated_files.add(str(file))
            outdated_classes.add(name.text)
            if not args.delete_old_translations:
                error(f'Translation context "{name.text}" is outdated', file)

# Remove the outdated translations, or display a helpful warning
# Use regex here instead of XML parser because we want to cause minimal impact to whitespace etc
if outdated_files:
    if args.delete_old_translations:
        # Insert the class names into the regex pattern before compiling it
        ts_pattern = re.compile(ts_pattern_template.format('|'.join(outdated_classes)))
        for file in outdated_files:
            output = ts_pattern.sub('', Path(file).read_text())
            Path(file).write_text(output)
    else:
        print('\nThe translations in `data/locale` are outdated. If you have renamed a class, please update all',
              '.ts files accordingly using search and replace. If you have deleted a class you can remove the',
              'outdated translations by running `tests/scripted/check-namespace --delete-old-translations`.\n',
              file=sys.stderr, sep='\n')


caption('summary')

print(f'{str(errors)} errors.', file=sys.stderr)
exit(1 if errors > 0 else 0)
