/* This file is generated by generate_checkers.pl < functions - do not edit by hand. */
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  static int (*func)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
  char* error;

  if (in_rt)
  {
    printf("select() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)) dlsym(RTLD_NEXT, "select");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing select\n");
    abort();
  }
  return(func(nfds, readfds, writefds, exceptfds, timeout));
}

unsigned int sleep(unsigned int seconds)
{
  static unsigned int (*func)(unsigned int seconds);
  char* error;

  if (in_rt)
  {
    printf("sleep() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (unsigned int (*)(unsigned int seconds)) dlsym(RTLD_NEXT, "sleep");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing sleep\n");
    abort();
  }
  return(func(seconds));
}

void * malloc(size_t size)
{
  static void * (*func)(size_t size);
  char* error;

  if (in_rt)
  {
    printf("malloc() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (void * (*)(size_t size)) dlsym(RTLD_NEXT, "malloc");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing malloc\n");
    abort();
  }
  return(func(size));
}

void * realloc(void *ptr, size_t size)
{
  static void * (*func)(void *ptr, size_t size);
  char* error;

  if (in_rt)
  {
    printf("realloc() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (void * (*)(void *ptr, size_t size)) dlsym(RTLD_NEXT, "realloc");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing realloc\n");
    abort();
  }
  return(func(ptr, size));
}

void free(void* ptr)
{
  static void (*func)(void* ptr);
  char* error;

  if (in_rt)
  {
    printf("free() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (void (*)(void* ptr)) dlsym(RTLD_NEXT, "free");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing free\n");
    abort();
  }
  return(func(ptr));
}

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
  static int (*func)(pthread_mutex_t *mutex);
  char* error;

  if (in_rt)
  {
    printf("pthread_mutex_lock() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(pthread_mutex_t *mutex)) dlsym(RTLD_NEXT, "pthread_mutex_lock");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing pthread_mutex_lock\n");
    abort();
  }
  return(func(mutex));
}

int pthread_join(pthread_t thread, void **value_ptr)
{
  static int (*func)(pthread_t thread, void **value_ptr);
  char* error;

  if (in_rt)
  {
    printf("pthread_join() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(pthread_t thread, void **value_ptr)) dlsym(RTLD_NEXT, "pthread_join");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing pthread_join\n");
    abort();
  }
  return(func(thread, value_ptr));
}

pid_t wait(int* status)
{
  static pid_t (*func)(int* status);
  char* error;

  if (in_rt)
  {
    printf("wait() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (pid_t (*)(int* status)) dlsym(RTLD_NEXT, "wait");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing wait\n");
    abort();
  }
  return(func(status));
}

int poll(struct pollfd *fds, nfds_t nfds, int timeout)
{
  static int (*func)(struct pollfd *fds, nfds_t nfds, int timeout);
  char* error;

  if (in_rt)
  {
    printf("poll() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(struct pollfd *fds, nfds_t nfds, int timeout)) dlsym(RTLD_NEXT, "poll");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing poll\n");
    abort();
  }
  return(func(fds, nfds, timeout));
}

int vprintf(const char *format, va_list ap)
{
  static int (*func)(const char *format, va_list ap);
  char* error;

  if (in_rt)
  {
    printf("vprintf() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(const char *format, va_list ap)) dlsym(RTLD_NEXT, "vprintf");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing vprintf\n");
    abort();
  }
  return(func(format, ap));
}

int vfprintf(FILE *stream, const char *format, va_list ap)
{
  static int (*func)(FILE *stream, const char *format, va_list ap);
  char* error;

  if (in_rt)
  {
    printf("vfprintf() is called while in rt section\n");
#if ABORT_ON_VIOLATION
    abort();
#endif
  }
  if(!func)
  {
    func = (int (*)(FILE *stream, const char *format, va_list ap)) dlsym(RTLD_NEXT, "vfprintf");
    if ((error = dlerror()) != NULL) {
      fputs(error, stderr);
      abort();
    }
  }
  if(!func)
  {
    fprintf(stderr, "Error dlsym'ing vfprintf\n");
    abort();
  }
  return(func(stream, format, ap));
}

